(()=>{const a="object"==typeof global,c=a?global:"object"==typeof window&&window,d=b=>c.requestIdleCallback?c.requestIdleCallback(b):a?c.setImmediate(b):setTimeout(b,0),b=a=>"object"==typeof a&&e(a.then),e=a=>a instanceof Function,f=a=>"object"==typeof a&&a.constructor===Object,g=a=>"string"==typeof a,h=a=>a instanceof RegExp,i=(a,b)=>{for(const c in b)Object.defineProperty(a,c,{value:b[c],enumerable:!1,configurable:!1});return a},j=()=>{const a={binds:new Map,bound:new Set,get(b,c){if(a.binds.has(b))return a.binds.get(b).get(c)},set(b,c,e,f){a.binds.has(b)||a.binds.set(b,new Map),a.bound.add(e),a.binds.get(b).set(c,e),f&&d(e)},delete(b,c){a.binds.has(b)&&(a.bound.delete(a.binds.get(b).get(c)),a.binds.get(b).delete(c),!a.binds.get(b).size&&a.binds.delete(b))},update:d.bind(void 0,()=>a.bound.forEach(a=>a())),clear(){a.bound.forEach(a=>a.revoke()),a.bound.clear(),a.binds.forEach(a=>a.clear()),a.clear()}};return a},k=({val:a,history:k,maxhistory:l,pre:m,prescreen:n,screen:o,mutate:p,fail:q,views:r,revoked:s})=>{!0===k&&(k=[]);let t=!1;const u=j(),v=(b,c,d,f)=>{const h=g(d);if(h&&!(d in x))throw new Error("state.bind: cannot create bind to undefined view");let i;return i=e(c)?h?()=>c(b,x[d]):()=>c(b,a):h?()=>{b[c]=x[d]}:()=>{b[c]=a},i.revoke=()=>{u.delete(b,c),f&&f()},u.set(b,c,i,void 0!==a),i};v.input=(b,c)=>{const d=()=>{b.value=a},e=()=>{A(b.value.trim())};return b.addEventListener("input",e),d.revoke=()=>{b.removeEventListener("input",e),u.delete(b,"value"),c&&c()},u.set(b,"value",d,void 0!==a),d};const w=(a,f,g)=>{void 0!==a&&a.appendChild&&([f,a]=[a,void 0]);const h=new c.Text;f&&f.appendChild?d(()=>f.appendChild(h)):e(f)&&(g=f);const i=v(h,"textContent",a,()=>{h.textContent="",g&&g();try{h.remove()}catch(a){}});return i.text=h,i},x=()=>a,y=new Set,z=(b,c)=>{if(!e(c))throw new TypeError("a view should be a function");if(y.has(b))throw new Error("state: duplicate view");y.add(b),Object.defineProperty(x,b,{get:()=>c(a)}),w[b]=(a,c,d)=>w(b,a,c,d)};if(f(r)){for(const a in r)z(a,r[a]);r=void 0}if(void 0!==o&&h(o)){const a=o;o=b=>g(b)&&a.test(b)}const A=c=>{if(!(t||c===a)){if(e(c)&&(c=c(a)),void 0===c)throw new Error("state.mutate: cannot create mutation from undefined");else if(e(c))throw new TypeError("state: cannot accept function values");if(b(c))return c.then(a=>A(a),a=>q(c,a));if(m&&(n||!n(c,a)?q(c,new Error("failed prescreen")):c=m(c,a)),o&&!o(c,a)){const a=new Error("failed screening");if(q)q(c,a);else throw a}else a=c,u.update(),k&&(k.push(a),void 0!==l&&k.length>l&&k.shift()),p&&p(a)}},B=i(a=>(void 0!==a&&A(a),a),{bind:v,text:w,mutate:A,history:k,view:x,toJSON:x,createView:z,binds:u,revoke(){u.clear(),a=void 0,y.forEach(a=>{x[a]=void 0}),y.clear(),t=!0,k&&(k.length=0),s&&s()}});return Object.freeze(B)};k.collection=a=>{if(!f(a))throw new Error("stateCollection needs a model object");for(let b in a)f(a[b])&&(a[b]=k(a[b]));return i(a,{toObj:()=>k.collection.toObj(a),mutate(b,c){if(f(b))for(const c in b)a[c]&&a[c].mutate(b[c]);else void 0!==b&&void 0!==c&&a[b].mutate(c)},reactive(){const b={};for(let c in a)Object.defineProperty(b,c,{get:()=>a[c].view(),set:b=>a[c].mutate(b)});return b}})},k.collection.toObj=a=>{const b={};for(const c in a)b[c]=a[c].view();return b},"object"==typeof exports&&"undefined"!=typeof module?module.exports=k:"function"==typeof i&&i.amd?i(["state"],()=>k):c.state=k})();